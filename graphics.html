<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beaded Graphics — редактор</title>
  <style>
    :root{
      --bg:#000; --fg:#fff;
      --border: rgba(255,255,255,.15);
      --border-strong: rgba(255,255,255,.22);
      --panel-bg: rgba(255,255,255,.03);
      --panel-bg-2: rgba(255,255,255,.04);
      --input-bg: rgba(255,255,255,.06);
      --muted: rgba(255,255,255,.65);
      --hint: rgba(255,255,255,.55);
      --shadow: rgba(0,0,0,.35);

      /* switch */
      --switch-track: rgba(255,255,255,.18);
      --switch-track-on: rgba(255,255,255,.26);
      --switch-knob: rgba(255,255,255,.90);

      color-scheme: dark;
    }

    body{
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      display:grid; place-items:center; min-height:100vh;
    }

    .wrap{ width:min(1200px, 94vw); }

    /* NAV */
    .tabs{ display:flex; gap:10px; margin-bottom:2px; }
    .tab{
      flex:1;
      text-align:center;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--panel-bg-2);
      color: var(--fg);
      text-decoration:none;
      font-size:14px;
    }
    .tab.active{
      border-color: var(--border-strong);
      background: var(--input-bg);
    }

    /* PANEL */
    .panel{
      display:grid; gap:10px;
      padding:12px 14px;
      border:1px solid var(--border);
      border-radius:14px; margin-bottom:12px;
      background: var(--panel-bg);
      box-shadow: 0 10px 30px var(--shadow);
    }

    .top-row{ display:flex; gap:12px; align-items:center; }

    .label{
      opacity:.9; font-size:14px; color: var(--fg);
      min-width:160px;
    }

    input[type="range"]{ width:100%; flex:1; }

    /* число — максимально близко к ползунку */
    .num{
      width:44px;
      text-align:right;
      opacity:.95;
      color: var(--fg);
      flex:0 0 auto;
      margin-left:4px;
      margin-right:6px;
      font-weight:700;
    }

    .hintline{
      font-size:12px;
      color: var(--muted);
      margin-top:2px;
    }

    /* Switch */
    .switch{
      position:relative;
      width:52px; height:30px;
      flex:0 0 auto;
    }
    .switch input{ display:none; }
    .slider{
      position:absolute; inset:0;
      border-radius:999px;
      background: var(--switch-track);
      border:1px solid var(--border-strong);
      transition: .2s ease;
    }
    .slider:before{
      content:"";
      position:absolute; top:50%; left:4px;
      width:22px; height:22px;
      border-radius:999px;
      transform: translateY(-50%);
      background: var(--switch-knob);
      transition: .2s ease;
      box-shadow: 0 6px 16px var(--shadow);
    }
    .switch input:checked + .slider{
      background: var(--switch-track-on);
    }
    .switch input:checked + .slider:before{
      transform: translate(22px, -50%);
    }

    .toggleBox{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--panel-bg-2);
      min-width:260px;
    }
    .toggleBox .left{
      display:flex; flex-direction:column; gap:2px;
      min-width:0; flex:1;
    }
    .toggleBox .title{ font-size:14px; color:var(--fg); }
    .toggleBox .hint{ font-size:12px; color:var(--muted); }

    /* photo button */
    .iconBtn{
      width:46px; height:46px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--panel-bg-2);
      display:grid; place-items:center;
      cursor:pointer;
      flex:0 0 auto;
    }
    .iconBtn img{ width:22px; height:22px; opacity:.95; display:block; }

    /* undo / redo — больше */
    .undoRedo { display:flex; gap:10px; flex:0 0 auto; }
    .iconSmall{
      width:54px; height:46px;
      border-radius:14px;
      border:1px solid var(--border);
      background:var(--panel-bg-2);
      display:grid; place-items:center;
      cursor:pointer;
      font-size:22px;
      line-height:1;
    }

    /* STAGE */
    .stage{
      border-radius:18px; overflow:hidden;
      border:1px solid var(--border);
      background: var(--bg);
      box-shadow: 0 18px 50px var(--shadow);
      position:relative;
      touch-action: none;
      min-height:420px;
    }
    canvas{ display:block; width:100%; height:auto; }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="panel">
      <div class="tabs">
        <a class="tab" href="./text.html">Текст</a>
        <a class="tab active" href="./graphics.html">Графика</a>
      </div>

      <div class="top-row">
        <div style="flex:1; display:flex; gap:12px; align-items:center;">
          <div class="label">Количество бусин</div>
          <input id="beads" type="range" min="0" max="260" value="55" />
          <div class="num"><span id="beadsVal">55</span></div>
        </div>

        <div class="undoRedo">
          <button id="undoBtn" class="iconSmall" title="Отмена (Ctrl/Cmd+Z)">⟲</button>
          <button id="redoBtn" class="iconSmall" title="Возврат (Ctrl/Cmd+Y)">⟳</button>
        </div>

        <button class="iconBtn" id="photoBtn" title="Добавить фото">
          <img src="./picture.svg" alt="Add photo">
        </button>
        <input id="photoInput" type="file" accept="image/*" hidden />
      </div>

      <div class="top-row">
        <div class="toggleBox" style="flex:0 0 auto;">
          <div class="left">
            <div class="title">Бусины</div>
            <div class="hint"><span id="beadsModeLabel">Цветные</span></div>
          </div>
          <label class="switch" title="Цветные / Белые">
            <input id="beadsMode" type="checkbox" />
            <span class="slider"></span>
          </label>
        </div>
      </div>

      <div class="hintline">
        Рисование: зажми мышь/палец и веди. Фото: кликай по фото → двигай; тяните за угол → масштаб; колёсико → масштаб.
      </div>
    </div>

    <div class="stage">
      <canvas id="c"></canvas>
    </div>

  </div>

<script>
  const COLORS = ["#00ADEF","#F88ED0","#FFF301","#3051C4","#DF1C02","#66FFB3","#7C4DFF","#9BE870"];
  const BEAD_RADIUS = 16;

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const beadsInp = document.getElementById("beads");
  const beadsVal = document.getElementById("beadsVal");

  const beadsModeInp = document.getElementById("beadsMode");
  const beadsModeLabel = document.getElementById("beadsModeLabel");

  const photoBtn = document.getElementById("photoBtn");
  const photoInput = document.getElementById("photoInput");

  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");

  // ===== ВАЖНО: логические размеры в CSS-пикселях =====
  let viewW = 1400;
  let viewH = 720;

  // линии
  let strokes = [];
  let drawing = false;
  let current = [];

  // фото
  let photo = { img:null, x:0, y:0, scale:1, rotation:0 };

  // режим
  let mode = "none"; // draw | photo-drag | photo-resize | photo-pinch
  let photoDragOffset = { dx:0, dy:0 };
  let resizeCorner = null;

  // resize state (чтобы масштаб не "экспоненциально" улетал)
  let resizeStart = { scale:1, halfDiag:1 };

  // pinch
  let pinch = { active:false, startDist:0, startScale:1, startCenter:{x:0,y:0}, startPos:{x:0,y:0} };

  // undo/redo
  const undoStack = [];
  const redoStack = [];
  const MAX_STACK = 80;

  function mulberry32(seed){
    return function(){
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ (t>>>15), t | 1);
      t ^= t + Math.imul(t ^ (t>>>7), t | 61);
      return ((t ^ (t>>>14))>>>0) / 4294967296;
    };
  }

  // ===== Координаты курсора: ТОЛЬКО в CSS-пикселях (viewW/viewH) =====
  function getPos(e){
    const r = canvas.getBoundingClientRect();
    const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
    return {
      x: (p.clientX - r.left) * (viewW / r.width),
      y: (p.clientY - r.top)  * (viewH / r.height)
    };
  }

  function getTwoTouch(e){
    const r = canvas.getBoundingClientRect();
    const t0 = e.touches[0], t1 = e.touches[1];
    const p0 = { x:(t0.clientX - r.left) * (viewW/r.width), y:(t0.clientY - r.top) * (viewH/r.height) };
    const p1 = { x:(t1.clientX - r.left) * (viewW/r.width), y:(t1.clientY - r.top) * (viewH/r.height) };
    return { p0, p1 };
  }

  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function center(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

  // ===== Photo rect / handles =====
  function getPhotoRect(){
    if (!photo.img) return null;
    const iw = photo.img.width * photo.scale;
    const ih = photo.img.height * photo.scale;
    const left = photo.x - iw/2;
    const top  = photo.y - ih/2;
    const right = left + iw;
    const bottom = top + ih;
    return {
      left, top, right, bottom, iw, ih,
      tl:{x:left,y:top}, tr:{x:right,y:top}, bl:{x:left,y:bottom}, br:{x:right,y:bottom}
    };
  }

  function pointInRect(p, rect){
    return p.x >= rect.left && p.x <= rect.right && p.y >= rect.top && p.y <= rect.bottom;
  }
  function isPointOnCorner(p, c, s=12){
    return (p.x >= c.x-s && p.x <= c.x+s && p.y >= c.y-s && p.y <= c.y+s);
  }
  function cornerHit(p){
    const rect = getPhotoRect();
    if (!rect) return null;
    if (isPointOnCorner(p, rect.tl)) return "tl";
    if (isPointOnCorner(p, rect.tr)) return "tr";
    if (isPointOnCorner(p, rect.br)) return "br";
    if (isPointOnCorner(p, rect.bl)) return "bl";
    return null;
  }

  // ===== Undo/Redo state =====
  function copyState(){
    return {
      strokes: strokes.map(line => line.map(pt => ({x:pt.x, y:pt.y}))),
      photo: (photo.img ? { src: photo.img.src, x: photo.x, y: photo.y, scale: photo.scale, rotation: photo.rotation } : null)
    };
  }

  function restoreState(st){
    strokes = st.strokes.map(line => line.map(pt => ({x:pt.x, y:pt.y})));
    if (st.photo && st.photo.src){
      const img = new Image();
      img.onload = () => {
        photo.img = img;
        photo.x = st.photo.x;
        photo.y = st.photo.y;
        photo.scale = st.photo.scale;
        photo.rotation = st.photo.rotation;
        redraw();
      };
      img.src = st.photo.src;
    } else {
      photo.img = null;
    }
    redraw();
  }

  function pushState(){
    undoStack.push(copyState());
    if (undoStack.length > MAX_STACK) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedo();
  }

  function updateUndoRedo(){
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
    undoBtn.style.opacity = undoBtn.disabled ? 0.45 : 1;
    redoBtn.style.opacity = redoBtn.disabled ? 0.45 : 1;
  }

  function undo(){
    if (undoStack.length === 0) return;
    const cur = copyState();
    redoStack.push(cur);
    const prev = undoStack.pop();
    restoreState(prev);
    updateUndoRedo();
  }
  function redo(){
    if (redoStack.length === 0) return;
    const cur = copyState();
    undoStack.push(cur);
    const next = redoStack.pop();
    restoreState(next);
    updateUndoRedo();
  }

  // ===== Drawing helpers =====
  function drawBackground(){
    ctx.clearRect(0,0,viewW,viewH);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,viewW,viewH);
  }

  function drawPhoto(){
    if (!photo.img) return;

    ctx.save();
    ctx.translate(photo.x, photo.y);
    ctx.rotate(photo.rotation);
    ctx.scale(photo.scale, photo.scale);
    ctx.drawImage(photo.img, -photo.img.width/2, -photo.img.height/2);
    ctx.restore();

    // рамка + ручки (без rotation — как в редакторах)
    const rect = getPhotoRect();
    if (!rect) return;

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.strokeRect(rect.left, rect.top, rect.iw, rect.ih);
    ctx.setLineDash([]);

    const corners = [rect.tl, rect.tr, rect.br, rect.bl];
    for (const c of corners){
      ctx.fillStyle = "#111";
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.rect(c.x-8, c.y-8, 16, 16);
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawStroke(points){
    if (points.length < 2) return;
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.stroke();
  }

  function polylineLength(points){
    let len=0;
    for (let i=1;i<points.length;i++){
      len += Math.hypot(points[i].x - points[i-1].x, points[i].y - points[i-1].y);
    }
    return len;
  }

  function pointAt(points, d){
    let acc=0;
    for (let i=1;i<points.length;i++){
      const a=points[i-1], b=points[i];
      const seg=Math.hypot(b.x-a.x, b.y-a.y);
      if (acc+seg >= d){
        const t = seg===0 ? 0 : (d-acc)/seg;
        return { x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t };
      }
      acc+=seg;
    }
    return points[points.length-1] || {x:0,y:0};
  }

  function beadFill(rand){
    if (beadsModeInp.checked) return "#fff";
    return COLORS[Math.floor(rand()*COLORS.length)];
  }

  function beadStroke(){
    // для белых бусин слегка темнее обводка, чтобы читалось на белом фото тоже
    return beadsModeInp.checked ? "rgba(0,0,0,.22)" : "rgba(255,255,255,.18)";
  }

  function drawBeadsOnStroke(points, count, seedBase){
    const total = polylineLength(points);
    if (total <= 1 || count <= 0) return;

    const rand = mulberry32(seedBase);
    const pad = total * 0.06;
    const start = pad;
    const end = Math.max(start+1, total - pad);
    const span = end - start;

    const st = beadStroke();

    for (let i=0;i<count;i++){
      const t = (count===1) ? 0.5 : i/(count-1);
      const jitter = (rand()-0.5)*0.08;
      const d = start + span * Math.min(1, Math.max(0, t + jitter));
      const p = pointAt(points, d);

      ctx.beginPath();
      ctx.arc(p.x, p.y, BEAD_RADIUS, 0, Math.PI*2);
      ctx.fillStyle = beadFill(rand);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = st;
      ctx.stroke();
    }
  }

  function redraw(){
    const beadCount = parseInt(beadsInp.value, 10);
    beadsVal.textContent = String(beadCount);

    beadsModeLabel.textContent = beadsModeInp.checked ? "Белые" : "Цветные";

    drawBackground();
    drawPhoto();

    for (let s=0;s<strokes.length;s++){
      const pts = strokes[s];
      drawStroke(pts);

      const per = strokes.length ? Math.floor(beadCount / strokes.length) : 0;
      const extra = strokes.length ? (beadCount % strokes.length) : 0;
      const n = per + (s < extra ? 1 : 0);

      drawBeadsOnStroke(pts, n, 12345 + s*999);
    }

    if (drawing && current.length>1){
      drawStroke(current);
    }
  }

  // ===== Pointer events =====
  function startPointer(e){
    // pinch (2 пальца) — масштаб фото
    if (e.touches && e.touches.length === 2 && photo.img){
      e.preventDefault();
      const {p0,p1} = getTwoTouch(e);
      pinch.active = true;
      pinch.startDist = dist(p0,p1);
      pinch.startScale = photo.scale;
      pinch.startCenter = center(p0,p1);
      pinch.startPos = { x: photo.x, y: photo.y };
      mode = "photo-pinch";
      return;
    }

    const p = getPos(e);

    // resize corner
    const c = cornerHit(p);
    if (c){
      e.preventDefault();
      mode = "photo-resize";
      resizeCorner = c;
      // зафиксируем стартовые параметры (исправляет "сломанный" resize)
      const rect = getPhotoRect();
      resizeStart.scale = photo.scale;
      resizeStart.halfDiag = rect ? Math.hypot(rect.iw/2, rect.ih/2) : 1;
      pushState();
      return;
    }

    // drag photo
    if (photo.img){
      const rect = getPhotoRect();
      if (rect && pointInRect(p, rect)){
        e.preventDefault();
        mode = "photo-drag";
        photoDragOffset.dx = p.x - photo.x;
        photoDragOffset.dy = p.y - photo.y;
        pushState();
        return;
      }
    }

    // draw
    e.preventDefault();
    mode = "draw";
    drawing = true;
    current = [p];
    redraw();
  }

  function movePointer(e){
    if (mode === "photo-pinch" && e.touches && e.touches.length === 2 && photo.img){
      e.preventDefault();
      const {p0,p1} = getTwoTouch(e);
      const d = dist(p0,p1);
      const c = center(p0,p1);

      const k = (pinch.startDist === 0) ? 1 : (d / pinch.startDist);
      photo.scale = Math.max(0.05, Math.min(10, pinch.startScale * k));

      const dx = c.x - pinch.startCenter.x;
      const dy = c.y - pinch.startCenter.y;
      photo.x = pinch.startPos.x + dx;
      photo.y = pinch.startPos.y + dy;

      redraw();
      return;
    }

    if (mode === "photo-drag"){
      e.preventDefault();
      const p = getPos(e);
      photo.x = p.x - photoDragOffset.dx;
      photo.y = p.y - photoDragOffset.dy;
      redraw();
      return;
    }

    if (mode === "photo-resize"){
      e.preventDefault();
      const p = getPos(e);

      // масштаб по диагонали от центра к текущей точке
      const dx = Math.abs(p.x - photo.x);
      const dy = Math.abs(p.y - photo.y);
      const halfDiagNew = Math.hypot(dx, dy);

      const k = (resizeStart.halfDiag === 0) ? 1 : (halfDiagNew / resizeStart.halfDiag);
      photo.scale = Math.max(0.05, Math.min(10, resizeStart.scale * k));

      redraw();
      return;
    }

    if (mode === "draw"){
      e.preventDefault();
      const p = getPos(e);
      const last = current[current.length-1];
      if (!last || Math.hypot(p.x-last.x, p.y-last.y) > 2){
        current.push(p);
        redraw();
      }
    }
  }

  function endPointer(e){
    if (mode === "draw"){
      if (drawing){
        drawing = false;
        if (current.length > 1){
          strokes.push(current.map(pt => ({x:pt.x, y:pt.y})));
          pushState();
        }
        current = [];
      }
    }
    pinch.active = false;
    mode = "none";
    resizeCorner = null;
    redraw();
  }

  // wheel zoom photo (над фото)
  canvas.addEventListener("wheel", (e) => {
    if (!photo.img) return;
    const p = getPos(e);
    const rect = getPhotoRect();
    if (!rect || !pointInRect(p, rect)) return;

    e.preventDefault();
    const delta = -e.deltaY;
    const factor = Math.exp(delta * 0.0018);

    const prev = photo.scale;
    const next = Math.max(0.05, Math.min(10, prev * factor));
    const k = next / prev;

    // scale around cursor
    photo.x = p.x - (p.x - photo.x) * k;
    photo.y = p.y - (p.y - photo.y) * k;
    photo.scale = next;

    pushState();
    redraw();
  }, { passive:false });

  canvas.addEventListener("mousedown", startPointer);
  window.addEventListener("mousemove", movePointer);
  window.addEventListener("mouseup", endPointer);

  canvas.addEventListener("touchstart", startPointer, { passive:false });
  window.addEventListener("touchmove", movePointer, { passive:false });
  window.addEventListener("touchend", endPointer, { passive:false });
  window.addEventListener("touchcancel", endPointer, { passive:false });

  // ===== UI bindings =====
  beadsInp.addEventListener("input", redraw);
  beadsModeInp.addEventListener("change", redraw);

  photoBtn.addEventListener("click", () => photoInput.click());
  photoInput.addEventListener("change", () => {
    const file = photoInput.files && photoInput.files[0];
    if (!file) return;

    const img = new Image();
    img.onload = () => {
      photo.img = img;

      // стартовый масштаб: ~60% меньшей стороны холста
      const target = Math.min(viewW, viewH) * 0.6;
      const s = target / Math.max(img.width, img.height);
      photo.scale = Math.max(0.05, Math.min(10, s));

      photo.x = viewW / 2;
      photo.y = viewH / 2;

      pushState();
      redraw();
    };
    img.src = URL.createObjectURL(file);
  });

  undoBtn.addEventListener("click", undo);
  redoBtn.addEventListener("click", redo);

  window.addEventListener("keydown", (e) => {
    const isMac = navigator.platform.toUpperCase().includes("MAC");
    const mod = isMac ? e.metaKey : e.ctrlKey;
    if (!mod) return;

    const key = e.key.toLowerCase();
    if (key === "z" && !e.shiftKey){
      e.preventDefault(); undo();
    } else if (key === "y" || (key === "z" && e.shiftKey)){
      e.preventDefault(); redo();
    }
  });

  // ===== Retina-safe canvas resize (без сдвига курсора) =====
  function resizeCanvas(){
    const stage = canvas.parentElement;
    const r = stage.getBoundingClientRect();

    // CSS-логика
    viewW = Math.max(600, Math.floor(r.width));
    viewH = Math.max(360, Math.floor(r.width * (720/1400))); // сохраняем пропорцию как раньше

    // устройство
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(viewW * dpr);
    canvas.height = Math.floor(viewH * dpr);
    canvas.style.width  = viewW + "px";
    canvas.style.height = viewH + "px";

    // рисуем в логических координатах (CSS px)
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // если фото ещё не позиционировали — центрируем
    if (photo.img && (photo.x === 0 && photo.y === 0)){
      photo.x = viewW/2;
      photo.y = viewH/2;
    }

    redraw();
  }

  window.addEventListener("resize", resizeCanvas);

  // init
  pushState();
  updateUndoRedo();
  resizeCanvas();
  redraw();
</script>
</body>
</html>
